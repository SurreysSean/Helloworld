<h1> C++ Primer 5th阅读笔记</h1>  

说明：仅仅保留**某一段时间** ，**本作者**认为重要的内容，具备时效性且没有泛用性。
<h2> 第二章 变量与基本类型</h2>

2.1.3 字面值常量

!["page37 表2.2"](./书籍截图/指定字面值类型.png)

2.2.2 变量声明和定义的关系  
> + 变量声明：规定变量类型和定义  
> + 变量定义：包含声明，还负责初始化和申请存储空间
> + <span style="color:blue">extern</span>：声明一个变量而非定义【不要显式地初始化变量，会变成定义】。

![page41 note](./书籍截图/变量声明与定义.png)

2.3.2 指针
> 1. void指针
>> + void\*是一种特殊的指针类型，可用于存放任意对象的地址。
>> + 功能比其他指针少：与其他指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。
>> + 因为该地址包含的对象未知，所以不能直接操作void*指针所指的对象。

2.3.3 复合类型

> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有利于弄清楚它的真实含义。

> 1. 对指针的引用
```cpp
int i = 42;
int * pi;       //P是一个int型指针
int *&r = pi;     //r是一个对指针p的引用
```

2.4.4 <div id="constexpr">常量表达式和constexpr </div>
> 1. 是指值不会改变且在**编译过程**就能得到结果的表达式。
> 2. 将变量声明为 constexpr类型以使由编译器来验证变量的值是否是一个常量表达式。
> 3. constexpr修饰指针仅对指针本身有效，与指针指向的对象无关。

2.5.1 类型别名

![page61 指针、常量和类型别名](./书籍截图/指针、常量和类型别名.png)

2.5.2 auto说明符
> 1. auto会忽略顶层const（声明称const auto类型重新赋予顶层const属性），会保留底层const
> 2. 用auto定义多个变量时，必须保证变量的基本类型相同。
> 3. <div id="decltype">auto与decltype(expr/var):</div>
> > + auto变量需要推断类型，所以必须要初始化
> > + decltype使用参数的类型，可以不初始化；能保留顶层const
>>>  切记：decltype((variable))的结果永远是引用。而decltype(variable)的结果只有当variable本身是一个引用才是引用。

2.6.3 编写头文件
> 1. 文件保护符
>> + #define指令把一个名字设定为预处理变量；
>> + #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真；
>> + 一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
> ```cpp
> //example 如果文件未被包含，执行文件内容，否则忽略
> #ifndef var
> #define var
> ...         //该文件内容
> #endif
> ```

- - -

3.2.2 String对象
> 1. string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string
> ```cpp
> string s1 = s +",";    //正确，一个string与字面值常量相加
> string s2 = "hi" + "," //错误，两个运算对象都不是string
> ```

3.4.1 容器迭代器

> 谨记，但凡是使用了迭代器的循环体，都不要想迭代器素数的容器添加元素。

3.5.1 数组声明

> 想要理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读

3.5.5 与旧代码的接口

> 1. string对象装换为C风格字符串使用【string对象】.c_str

- - -

4.1.1 表达式的基本概念

> 1. 左值与右值
>> + 左值：当一个对象被用作左值时，使用的是对象的身份（在内存中的内容）
>> + 右值：当一个对象被用作右值时，使用的是对象的值（内容）

4.5 自增运算符
> + i++ （i--同理）
>> ```cpp
>> i_type func(i_type &i){
>>      i_type a = i;
>>      i = i+1;
>>      return a;
>>  }
>> ```

> + ++i （--i同理）
>> ```cpp
>> i_type func(i_type &i){
>>   i = i+1;
>>   return i;
>> }
>> ```
> + 自增运算符的优先级高于解引用

4.11.1 类型转换
> 1. 无符号对象的类型转换
>> + 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的；
>> + 如果是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。

4.11.3 显式类型转换
> 1. 避免使用强制类型转换
>> + static_cast,dynamic_cast,const_cast,reinterpret_cast都应当少用。每次书写强制类型转换语句都应当考虑是否能以其他方式实现。

4.12 运算符优先级表

![page147 运算符优先级表](./书籍截图/运算符优先级表1.png)

![page148 运算符优先级表](./书籍截图/运算符优先级表2.png)

- - -

6.2.3 const形参和实参
> 1. 尽量使用常量引用
>> + 把函数不会改变的参数定义成普通引用，会导致无法接受常量作为参数（比如字面值常量）

6.2.4 数组形参
> 1. 传递多维数组
>> + 因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的部分，不能省略。
>> ```cpp
>> //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组
>> void print(int (*matrix)[10],int rowSize){...}
>>``` 

6.2.6 含有可变形参的函数
> 1. initializer_list形参
>> + 用initializer_list<type>()作为形参后，可用"{}"传入数量可变的参数;
>>![page198 表6.1](./书籍截图/initializer_list操作.png)
> 2. 省略号形参
>> + 应该仅仅用于C和C++的通用类型
>> + 应注意，大多数类类型对象在传递给省略号形参时都无法正确拷贝

6.3.3 返回数组指针
> 1. 使用尾置返回类型，适用于返回类型比较复杂
>> ```cpp
>> //func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
>> auto func(int i) -> int(*)[10];
>>```
> 2. 使用[decltype(与返回类型类型相同的参数)](#decltype)作为返回类型

6.4 函数重载
> 1. 重载与const形参
>> + 顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来;
>> + 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的;

6.5.2 [constexpr](#constexpr)函数
> 1. 基本性质
>> + constexpr函数被隐式指定为内联函数；
>> + 返回类型和所有形参都是字面值类型；
>> + 函数体中有且仅有一条return语句，其他语句只能包含不在**运行时**执行动作的语句；
>> ```cpp
>> //示例constexpr函数
>> constexpr int substract(const int a,const int b)
>> {
>>     return a-b;
>> }
>> ```
> 2. 如果constexpr函数用于常量表达式
>> ```cpp
>> //使用常量表达式调用此函数就会返回常量表达式
>> constexpr int res = substract(9,5);//res = 4
>> ```
> 3. constexpr函数用于非常量表达式
>> ```cpp
>> //使用非常量表达式调用此类函数，返回非常量表达式
>> int a=9,b=5;
>> int res = substract(a,b);//res = 4
>> constexpr int res = substract(a,b);//编译报错，返回值是非常量表达式
>> ```

6.5.3 调试帮助
> 1. assert(expr)
>> 对expr求值，如果表达式为假(即0，仅为假时有动作), assert输出信息并终止程序的执行。
> 2. NEDBUG
>> + 如果定义了NEDBUG，则assert什么也不做
>> + 预处理器定义的有利于调试的名字
>>> \__func__ 存放函数的名字

>>> \__FILE__ 存放文件名的字符串字面值

>>> \__TIME__ 存放文件编译时间的字符串字面值

>>> \__DATE__ 存放文件编译日期的字符串字面值

6.7 函数指针
> 1. 调用函数指针
>> ```cpp
>>void func(int param);
>> void (*pf)(int param);
>> // 下列两种赋值方式等价
>> pf = param;
>> pf = &param;
>> // 下列三种调用方式等价
>> pf(param);
>> (*pf)(param);
>> func(param);
>> ```
> 2. 函数指针形参
>> ```cpp
>> //下列两种声明函数指针形参方式等价
>> void pfpFunction(void pf(int param));
>> void pfpFunction(void (*pf)(int param));
>> //直接使用函数作为形参自动转换为指针
>> pfpFunction(func);
>>```
> 3. 返回函数指针
>> ```cpp
>> //使用类型别名
>>using F = int(int*,int*);//F是函数类型
>>using FP = int(*)(int*,int*);//FP是函数指针
>>//同样可用使用auto尾置和decltype的方法(注：decltype()返回的是函数类型)
>>``` 
- - - 

7.1.1 设计类
> 1. 常量对象、常量对象的引用或指针都只能调用常量成员函数。

7.1.4 构造函数
> 1. =default
>> 如果既需要自定义构造函数又需要默认构造函数，可以在一个构造函数声明后加上=default

7.2.1 友元
> 1. 友元声明只能在class的内部，但是不受它的区域访问控制级别的约束；
> 2. 当使用在类中声明过的友元函数时，友元函数在类外被声明过是必需的（可能某些编译器会隐式完成）；

7.3.1 类的其他特性
> 1. mutable能将声明类中某些数据成员的可变，即使类是const也是可以修改这些成员

7.4.1 名字查找与类的定义域
> 1. 编译器处理完类中的全部声明后才会处理成员函数定义；
> 2. 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：
> 3. 不要隐藏外层作用域中可能被用到的名字。如果一定要这样使用，可以通过作用域运算符(::)访问外层被隐藏的变量；
> 4. 无论什么时候都应该牢记：**定义中只能使用已经被声明过的对象**。

7.5.1 构造函数列表初始化
> 1. 如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值；**建议使用构造函数初始值**；
> 2. 类成员的初始化顺序总是与它们在类定义出现顺序一致，所以建议在构造函数列表初始化成员时与定义中的顺序保持一致，尽量避免用成员去初始化另一个成员；

7.5.2 委托构造函数
> ```cpp
> //非委托构造函数(被委托)
> constructFunc(MemType1 p1,MemType2 p2):mem1(p1),mem2(p2){}
> //委托构造函数
> constructFunc():constructFunc(defaultValue1,defaultValue2){}
> ```

7.5.4 隐式的类类型转换
> 1. 只允许一步的（隐式）类类型转换；
>> 1. 定义class sale，假设函数func是接受sale参数，且sale可以用string进行初始化；
>> 2. 那么形如string s;func(s)的一步类型转换是合法的；
>> 3. 而func("aaaa")这样的类型转换不合法。
> 2. 当使用explicit声明构造函数时，它将只能以直接初始化（对应于拷贝初始化）的形式使用。编译器不会在自动转换中使用该构造函数。

7.6 类的静态成员
> 1. 静态成员声明
>> + 类的静态成员被所有对象共享，同时对象中不包含静态数据成员相关的数据。
>> + 静态成员函数也不与任何对象绑定在一起，它们不包含this指针。
>> + 作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。
> 2. 静态成员定义
>> + 静态成员必须在类外定义且只能定义一次；
>> + 在类外初始化，不应该在类内初始化（下有特例）。
>> + 可以提供const整数类型的类内初始值，此时**静态变量必须是字面值常量类型的constexpr**；

> 3. 仅适合静态成员的场景
>> + 静态成员可以是不完全类型（指针成员也可以是）
>> + 静态成员可以作为默认参数

- - -

8.1.2 IO条件状态

![page279 表8.2](./书籍截图/IO库条件状态-1.png)![page279 表8.2](./书籍截图/IO库条件状态-2.png)

8.1.3管理输出缓存
> 1. 导致缓存刷新的原因
>> 1. 程序正常结束;
>> 2. 缓存区满了;
>> 3. 操纵符显式刷新;
>> 4. 一个流可能关联另一个流。
> 2. 能够刷新缓存区的操作符
>> + flush/endl/ends都能立即刷新当前缓存区一次；
>> + unitbuf能设置每一次输出都刷新缓存区，nounitbuf关闭；
> 3. 程序崩溃时，输出缓存区不会刷新
> 4. 关联输入输出流
>> + 一个输入流被关联到一个输出流时，任何从输入流读取数据的操作都会先刷新关联的输出流；
>> + 通过tie()手动进行流关联
>>> + <iostream>.tie()不带参数返回指向该IO流关联的输出流的指针；
>>> + <iostream>.tie(&os)将这个IO流关联到输出流os上；

8.2.2 文件模式
> 1. 以out模式打开文件会丢弃文件已有数据,而ofstream默认的打开方式是out；
> 2. 保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式；

8.3 string流
> 头文件sstream定义istringstream/ostringstream/stringstream支持**内存**IO，这些类型对string进行与IO流相同的操作

小结
> + iostream处理控制台IO
> + fstream处理命名文件IO
> + stringstream完成内存string的IO