**chapter 2**

2.1 

> 1. 类型大小（最小值）
>> + int-16bit;
>> + long-32bit;
>> + long long-64bit;
>> + short-16bit;
> 2. 无符号数仅能表示非负数，带符号数则都可以表示。
> 3. double 64bit;float 32bit,double能表示的精度更高

2.2 选择double，能表示小数且高精度。

2.3 从上到下：32,2^32-32,32,-32,0,0

2.5 
> + a.字符，宽型字符，字符串，宽型字符串
> + b.整型，无符号整型，长整型，无符号长整型，8进制值，16进制值 
> + c.double,float,long double
> + d.int,unsigned,double,double

2.6 从上到下：10进制整型，8进制整型

2.7 依次："Who goes with Fergus\n"，字符串；31.4，long double；1024.0，float；3.14，long double

2.9 
> + 解释：非法定义，不合法的初始化操作；定义合法，隐式转换；非法定义，wage未被定义；定义合法，隐式转换。
> + 修改：(a)int input_value;cin>>input_value; (c)double salary=9999.99,wage=9999.99;

2.10 从上到下："",0,未知(**函数体内部**的**内置**类型不被初始化),""

2.11 依次：定义，定义，声明

2.12 依次：非法，合法，非法，非法，合法

2.13 100

2.14 合法，100 45

2.15 b 必须引用对象，d 引用必须初始化

2.16 依次：必须指定对象；合法,同d=i；合法，同i=d；类型必须同绑定对象匹配

2.17 10 10

2.18 略

2.19 引用同对象绑定，不是对象；指针是对象，存储对象内存空间的地址

2.20 i = i*i

2.21 (a)指针需要与被指向对象严格匹配；(b)指针应该存放对象的地址

2.22 依次：判断指针是否为空；判断p指向对象是否为0

2.23 略

2.24 void指针可存放任意对象的地址，long指针严格匹配long对象

2.25 
> + (a). ip:pointer\<int>,nullptr; i:int,0; r:reference,i;
> + (b). i:int,0; ip:pointer\<int>,0
> + (c). ip:pointer\<int>,nullptr; ip2:int,0

2.26 (a)常量必须初始化; (d)常量不可被修改。其他合法

2.27 依次：a.引用必须绑定对象；b.合法，指向int的常量指针；c.合法，常量引用可以直接绑定常量；d.合法，指向int常量的常量指针；e.合法，指针常量；f.不合法；g.合法，常量和常量引用

2.28 依次：i:整型；cp:常量指针，不合法，必须初始化；pl：int*；p2:常量指针，不合法，必须初始化；ic:整型常量，不合法，必须初始化；r:常量引用；p3：指向整型常量的常量指针,不合法，必须初始化；p:指向常量的指针

2.29 依次：a.合法，将const变量的值赋值给非const；b.不合法，非常量指针不能指向常量对象；c.不合法，非常量指针不能指向常量对象;d.合法，类型匹配；e.合法，int常量指针指向int对象，类型匹配；f.不合法，常变量不能重新赋值

2.30 依次：顶层；无const；无const；无const；底层；顶层&底层；底层

2.31 依次：合法；不合法；合法；不合法；不合法（常量指针不可修改指向）；

2.32 int null =0,*p = \&null;

2.33 42;42;42;不能将整型赋值给指针;不能将整型赋值给指针;常量引用不能被赋值（记住，c++是强类型语言，自动类型转化不能转指针）

2.34 略

2.35 i:const int;j:int;k:const int&;p:const int*;j2:const int;k2:const int&

2.36 a:int 4;b:int 4;c:int 4;d:int& 4

2.37 a:int 3;b:int 4;c:int 3;d:int& 4

2.38 
> + int a;auto b=a等同于decltype(a)b【int】;        
> + int \*a;auto b=\*a【int】不同于decltype(\*a) c【int&】; （同样可以距离const）

2.39 error: expected ';' after struct definition

- - -
**chapter 3**

3.1 略

3.3 输入运算符：遇到空白字符或换行符结束输出；getline()：遇到换行符才结束

3.9 合法输出'\0'

3.11 合法，c应为const char&；(设置一个类型为auto的引用时，初始值中的常量属性仍然保留)

3.12 依次：二维int数组；不正确，类型不匹配；含有10个"null"元素的字符串数组

3.13 依次：0个;10个,都是0;10个,都是42;1个,10;2个,{10,42};10个,""（确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象，下题同理）;10个,"hi"

3.18 不合法，ivec大小为0,不能通过下标添加元素；revise:ivec.push_back(42);

3.19 (1) vector\<int> v(10,42);    (2) vector\<int> {42,42,42...,42};  (3) vector\<int> v;for(int i=0;i!=10;i++) v.push_pack(42);第一种，定义时直接初始化而且比较简单

3.21 略

3.22 略

3.24 略

3.25 略

3.26 在数值运算上，两者结果相同，但是beg+end有int上溢的风险；mid=beg+(beg+end)/2通用性更强，两个迭代器/指针的加法运算但是支持减法运算。

3.27 依次：a错误，必须是常量表达式；c错误，返回值未必是常量表达式；d错误，字符加上'\0'共需要12个字符空间，st长度不够；

3.28 sa中都是""，ia中都是0，sa2都是""，ia2元素位置；

3.29 无法自动增长缩小，不支持迭代器。array必须提前确定数组大小

3.30 ia\[0]不会被访问，ix为10时，会读到没有定义的内存空间

3.32 略

3.33 scores中的元素都是未知值，因为scores是一个局部变量

3.34 令p1指向p2指向的元素，当p1是常量指针时该行为非法

3.36 略

3.37 hello,每个字符一行；（不正确，此外还会继续输出直到遇到'\0'，所以会产生未定义的结果）

3.38 指针中存放的所指向元素的内存地址，两个已知元素的内存地址相加只能得到一个未定义的内存地址，这是的无意义。除非这个内存地址被提前定义过

3.39 略

3.43 略

3.44 略

3.45 略
- - -
**chapter 4**
4.1 105

4.2 \(b) *\(vec.begin\()+1)

4.3 略

4.4 （12/3*4）+（5*15）+（24%4/2），res=91

4.5 依次：-86；-18；0；-2

4.6 if(i%2)

4.7 类型的值超出了该类型能表达的范围。int_max+1,int_min-1,unsigned(0)-1

4.8 先左后右的书序进行求值

4.9 cp不为空并且*cp不为零

4.11 
```cpp
if (a>b&&b>c&&c>d){}
```

4.12 等同于i!=\(j\<k)

4.13 依次：i=d=3;1=3,d=3.5;

4.14 依次：报错；i赋值为42，if condition为真；

4.15 不能将指针类型变量赋值给整型变量。dval = ival =0;pi=0;

4.16 \(a)逻辑运算符优先于赋值运算符，所以会将表达式getPtr\()!=0的值赋值给p；\(b)condition中是赋值运算而不是逻辑运算，所以i=1024表达式值为1，if condition恒为真
```cpp
//revise a
if ((p=getPtr())!=0){}
//revise b
if (i==1024){}
```

4.17 前置运算符先将变量取到寄存器中，后内存中变量运算；后置运算符先将内存中的变量运算，再取到寄存器中

4.18 无法输出vector中的第一个元素而且会产生越界错误

4.19 依次：若ptr不为空，且*ptr不为0，ptr+=1；ival且ival+1都不等于0，执行ival+=1；等同于vec\[ival]\<=vec\[ival+1],ival+=1

4.20 依次：解引用iter，iter自增；解引用iter，值自增；不合法，先执行成员选择符，但是'.'与iter不匹配；iter指向字符串是否为空；
iter自增，解引用iter；判断iter指向字符串是否为空，iter自增

4.22 略（条件运算符版本需条件运算符嵌套）

4.23 加法运算符优先于条件运算符，最后会变成判断字符类型常量和字符串类型变量是否相等，类型不匹配无法通过编译

4.24 
```cpp
//等同于
auto finalgrade = (grade>90)?"high pass":((grade<60?"fail":"pass"));
```

4.25 '@'，此处类型提升成32位：0x00003880

4.26 unsigned int 最小可能只有16位，可能无法表示30名学生

4.27 依次：3；7；1；1；

4.28 略，懒得搞

4.29 10;2\(指针占64位) 

4.30 
```cpp
//依次
sizeof(x)+y;
sizeof(p->mem[i]);
sizeof(a)<b;
sizeof(f());
```

4.31 前置编译效率更高；但是结果相同

4.32 计数loop：ix从0到5，ptr从ia\[0]指向ia\[5]

4.33 someValue为真执行\(++x,++y)，否则执行\(--x,--y)

4.34 依次：float转bool;int转float转double；char转int转double

4.35 依次：char转int转char；int转double,unsigned转double,最后double转float；unsigned转int转double；int转float转double转char

4.36 i*=static_cast\<int>(d)

4.37 依次：pv = static_cast\<void*>\(const_cast\<string*>ps); i = static_cast\<int>\(*pc);pv = static_cast\<void*>\(&d);pc = static_cast\<char*>\(pv);

4.38 j/i的结果强制转换为double类型

- - -
**chapter5**
5.1 不执行任何动作的语句，由单独一个分号构成。适用于语法上需要语句但是逻辑上不需要语句的场合。

5.2 用花括号括起来的语句和声明的序列，也称为复合语句。适用于语法上需要一条语句但是逻辑上需要多条语句的场合。

5.3 多条语句聚合成一条逗号运算符连接的语句，可读性降低了。

5.4 
```cpp
//a Revised --编译器报错：条件声明应当包含初始化
string::iterator iter = s.begin()
while(iter!=s.end()){}
//或者是
while (string::iterator iter = s.end()){}
//b Revised --变量status仅在while的作用域内生效
bool status =false;
while(bool status = find(word)){}
if (!status){}
```

5.5 略

5.6 略

5.7 
```cpp
//a revised
if (ival1!=ival2)
ival1=ival2;
else ival1= ival2 =0;
//b revised
if (ival < minval)
    minval = ival,occurs =1;
//c revised
int ival;
if (ival = get_value()) cout<<"ival = "<<ival<<endl;
if (!ival) cout<<"ival = 0\n";
//d revised
if (ival == 0)
ival = get_value();
```

5.8 在多个if-else和if语句嵌套时，怎么确定哪个if和哪个else匹配的问题叫做“悬垂else”。c++中else总是匹配离它最近的if

5.13 依次：case语句缺少break；default中的ix并未被定义；一个case智能对应一个值；没有考虑default情况

5.15 依次：计数循环ix从0到sz，if condition内ix未定义；含义同前，语法错误，缺少init-statement；含义同前，sz自增可能造成死循环

5.16 略。随便吧，在汇编代码里都是一个东西

5.18  依次：不断接受两个int并返回两数之和，需要使用花括号；ival应当定义在循环体外部；同前

5.21 略

5.22 
```cpp
int sz;
do {
    sz = get_size();
}while(sz<=0>);
```
- - -
**chapter6**
6.1 形参在函数定义中，函数体即是作用域；实参在主调函数中，进入被调函数后实参不能使用

6.2 依次：函数返回类型和实际返回值不匹配；未定义返回类型；形参重复；函数体应该用花括号包括

6.6 形参：由外部主调函数传入，离开函数生命周期结束；局部变量：由函数本身创建，离开函数生命周期结束；局部静态变量：由函数创建，生命周期随程序结束而结束。

6.8 略

6.9 略

6.11 略

6.13 前者函数内调用的形参是T的拷贝，不会影响实参T；后者函数内调用的形参是T的引用，对形参的任何修改都会影响实参；

6.14 形参是否是引用取决于是否希望在函数内修改实参的值

6.15 s是常量引用是为了防止被调用函数修改同时无需拷贝，occurs需要隐含返回值所以是普通引用。c可能是临时变量，所以不使用引用。s是普通引用则可能在函数中被修改，occurs是常量引用则不能被修改。

6.16 函数中不需要修改s，应该使用const string &s作为形参

6.17 程序就不写了。形参不同，前者是const string&，避免修改传入string对象；后者string &，因为需要将string中的大写字母修改为小写。

6.18 
```cpp
//a，比较两个矩阵是否相同
bool compare(const matrix &a,const matrix &b);
//b，将传入的迭代器只想的元素修改为指定值，返回传入的迭代器
vector<int>::iterator change_val(int a,vector<int>::iterator &iter);
```

6.19 \(a)不合法，参数数量不匹配；\(b)合法；\(c)合法；\(d)合法

6.20 形参引用是否是常量引用取决于是否在函数内修改实参的值。可能在函数中修改实参的值

6.23 略

6.24 形参只是希望接受10个元素的数组，但本质是接受一个指针，这个数组的大小对于函数仍然是完全未知的。如果传入一个5个元素的数组，就会出现越界错误。

6.28 const string &

6.29 只能声明成常量引用。普通引用与该类型包含的元素都是常量类型类型不匹配

6.30 return-statement with no value, in function returning 'bool'

6.31 无法返回局部对象的引用，函数结束后该引用的对象被释放；局部对象的常量引用也无效

6.32 合法，将数组ia依照下标赋值

6.34 当输入负数时，将会无限递归

6.35 val--是先执行当前语句在执行val-=1，如果传入val--，函数和下一层递归的val始终一样，递归不会停止。

6.36 string(&func())[10]

6.37 尾置返回类型：auto func() ->string (&)[10]；使用decltype：string s[10];decltype(s)& func()；类型别名:using s10 = string[10]; s10 & func()

6.38 decltype(odd) &arrptr(int i);

6.39 \(a)接受两个int或者const int类型，在函数体内不能更改。非法，顶层const不被区分，所以是重复声明；\(b) 返回一个double的函数get，非法，不同的返回类型不能重载；合法重载，接受一个double指针作为形参并返回一个double指针的函数

6.40 \(b)错误，函数参数列表从右到左赋予默认值

6.41 \(a)非法，传入参数数量不匹配；\(c)不符合初衷，将字符常面量隐式转换成了int类型

6.42 略

6.43 都可以放头文件中

6.44 函数返回类型前加上关键字inline即可

6.45 略

6.46 不能，因为传入的参数不是字面值类型，不符合常量表达式的要求

6.47 略

6.48 不合理，因为只要输入正常，assert都不会报错。assert宏常用于检查“不能发生”的情况

6.49 候选函数：与调用函数同名，声明在调用点可见；可行函数：实参和形参数量相等，且类型匹配或者和转换

6.50 依次:不合法，多个匹配有二义性;void f(int);void f(int,int);void (double,double=3.14)

6.51 略

6.52 依次：3、通过类型提升实现的匹配；4、算数类型匹配

6.53 依次：接受const int/int的值的函数；接受指针常量的函数，不合法，顶层const不会被区分；接受常量指针的函数

6.54 int f(int,int);vector<int (*)(int,int)>vec;

6.56 同编程作业6.55
- - -
**chapter7**
7.1 略

7.2 略

7.3 略

7.6 略

7.7 略

7.8 Sales_data在read中会被修改，而不会再print中修改

7.10 等同于Sales_data对象先读入data1，再读入data2

7.11 略

7.12 直接将istream传输给类成员

7.13 略

7.14 显式初始化即列表初始化，同若类tab有成员int a;string b。构造初始化为tab(int ta,string tb):a(ta),b(tb){}

7.16 没有限定。不希望被使用该类的代码访问的成员就应该用private，其他用public

7.17 class的默认访问权限是private，struct的默认访问权限是public

7.18 封装实现了接口与实现的分离，隐藏了类的实现细节。确保用户不会破坏封装对象的状态；类的具体实现修改是分离的，不会影响到用户级别代码

7.19 将成员name和address都声明成private，防止以不合理的方式修改；类方法都声明为public，方便使用者调用

7.20 想要使用类外部函数访问类private/protect成员时，需要声明为友元；优点：方便实现；缺点：可能导致类状态被破坏

7.21 略

7.25 能，因为不涉及分配新的空间

7.28 不会出错，但是会消耗更多内存空间

7.30 当形参存在与类成员同名的对象时，显式指针能够区分它们；能够将调用该成员函数的对象作为引用或指针返回

7.34 出现错误，pos未定义

7.35 Type由typedef定义，initVal由Type定义。类体内的Type是double的别名，类外的Type是string的别名,setVal定义用的是类体外的Type，会出现类型不匹配的错误;同时initVal这个函数成员没有被定义

7.36 用一个成员初始化另一个成员需要注意顺序，处理初始化的顺序与成员的声明顺序相同。这里就是顺序错误

7.37 依次：第三个、默认构造函数、第一个函数

7.38 X(istream &is = cin);

7.39 不合法，当使用无参数的构造函数构造对象时会产生二义性；

7.40 略

7.41 略

7.42 略

7.43 C\():NoDefault_mem\(0)\{} 在c的默认构造函数中，为NoDefault成员进行初始化，必须使用列表初始化，因为该成员没有默认构造函数

7.44 不合法，因为vector初始化时会调用NoDefault的不存在的默认构造函数，会报错

7.45 合法，因为我们在c的构造函数中处理了NoDefault的默认构造情况

7.46 \(a)错误，程序会为没有构造函数的类隐式提供一个默认函数；\(b)错误，参数列表的所有形参都有默认值的构造函数也是默认构造函数；\(c)错误，其他的程序可能需要调用这个类的默认构造函数；\(d)错误，情景应当是类没有定义构造函数

7.47 不应该，这样Sales_data不能接受字面值字符串作为参数进行构造。使用explicit的优点：避免隐式转化带来的隐患；缺点：不能使用隐式转换

7.48 不是explicit都能够构造成功；使用explicit，都能构造成功，因为explicit禁止的是被加前缀的函数被用于隐式转换，这里是直接用于构造，不会触发explicit的功能

7.49 依次：s隐式转换形成临时变量Sales_data，该变量作为实参传递给函数，形参通过实参产生一个临时变量；s隐式转换形成临时变量Sales_data，该变量作为实参传递给函数，形参产生该实参的普通引用；s隐式转换形成临时变量Sales_data，该变量作为实参传递给函数，形参产生该实参的常量引用

7.50 否

7.51 如果vector不使用explicit，vector\<int> = 10将会调用vector\<int>(10)，定义一个10元素的数组。但是前者就显得十分牵强

7.52 略

7.56 类的静态成员可以理解为所有类的实例可使用的全局变量；类内初始化时静态成员必须是字面值常量类型，并提供const证书类型的初始值；


