**chapter 2**

2.1 

> 1. 类型大小（最小值）
>> + int-16bit;
>> + long-32bit;
>> + long long-64bit;
>> + short-16bit;
> 2. 无符号数仅能表示非负数，带符号数则都可以表示。
> 3. double 64bit;float 32bit,double能表示的精度更高

2.2 选择double，能表示小数且高精度。

2.3 从上到下：32,2^32-32,32,-32,0,0

2.5 
> + a.字符，宽型字符，字符串，宽型字符串
> + b.整型，无符号整型，长整型，无符号长整型，8进制值，16进制值 
> + c.double,float,long double
> + d.int,unsigned,double,double

2.6 从上到下：10进制整型，8进制整型

2.7 依次："Who goes with Fergus\n"，字符串；31.4，long double；1024.0，float；3.14，long double

2.9 
> + 解释：非法定义，不合法的初始化操作；定义合法，隐式转换；非法定义，wage未被定义；定义合法，隐式转换。
> + 修改：(a)int input_value;cin>>input_value; (c)double salary=9999.99,wage=9999.99;

2.10 从上到下："",0,未知(**函数体内部**的**内置**类型不被初始化),""

2.11 依次：定义，定义，声明

2.12 依次：非法，合法，非法，非法，合法

2.13 100

2.14 合法，100 45

2.15 b 必须引用对象，d 引用必须初始化

2.16 依次：必须指定对象；合法,同d=i；合法，同i=d；类型必须同绑定对象匹配

2.17 10 10

2.18 略

2.19 引用同对象绑定，不是对象；指针是对象，存储对象内存空间的地址

2.20 i = i*i

2.21 (a)指针需要与被指向对象严格匹配；(b)指针应该存放对象的地址

2.22 依次：判断指针是否为空；判断p指向对象是否为0

2.23 略

2.24 void指针可存放任意对象的地址，long指针严格匹配long对象

2.25 
> + (a). ip:pointer\<int>,nullptr; i:int,0; r:reference,i;
> + (b). i:int,0; ip:pointer\<int>,0
> + (c). ip:pointer\<int>,nullptr; ip2:int,0

2.26 (a)常量必须初始化; (d)常量不可被修改。其他合法

2.27 依次：a.引用必须绑定对象；b.合法，指向int的常量指针；c.合法，常量引用可以直接绑定常量；d.合法，指向int常量的常量指针；e.合法，指针常量；f.不合法；g.合法，常量和常量引用

2.28 依次：i:整型；cp:常量指针，不合法，必须初始化；pl：int*；p2:常量指针，不合法，必须初始化；ic:整型常量，不合法，必须初始化；r:常量引用；p3：指向整型常量的常量指针,不合法，必须初始化；p:指向常量的指针

2.29 依次：a.合法，将const变量的值赋值给非const；b.不合法，非常量指针不能指向常量对象；c.不合法，非常量指针不能指向常量对象;d.合法，类型匹配；e.合法，int常量指针指向int对象，类型匹配；f.不合法，常变量不能重新赋值

2.30 依次：顶层；无const；无const；无const；底层；顶层&底层；底层

2.31 依次：合法；不合法；合法；不合法；不合法（常量指针不可修改指向）；

2.32 int null =0,*p = \&null;

2.33 42;42;42;不能将整型赋值给指针;不能将整型赋值给指针;常量引用不能被赋值（记住，c++是强类型语言，自动类型转化不能转指针）

2.34 略

2.35 i:const int;j:int;k:const int&;p:const int*;j2:const int;k2:const int&

2.36 a:int 4;b:int 4;c:int 4;d:int& 4

2.37 a:int 3;b:int 4;c:int 3;d:int& 4

2.38 
> + int a;auto b=a等同于decltype(a)b【int】;        
> + int \*a;auto b=\*a【int】不同于decltype(\*a) c【int&】; （同样可以距离const）

- - -
**chapter 3**

3.1 略

3.3 输入运算符：遇到空白字符或换行符结束输出；getline()：遇到换行符才结束

3.9 合法输出'\0'

3.11 合法，c应为const char&；(设置一个类型为auto的引用时，初始值中的常量属性仍然保留)

3.12 依次：二维int数组；不正确，类型不匹配；含有10个"null"元素的字符串数组

3.13 依次：0个;10个,都是0;10个,都是42;1个,10;2个,{10,42};10个,""（确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象，下题同理）;10个,"hi"

3.18 不合法，ivec大小为0,不能通过下标添加元素；revise:ivec.push_back(42);

3.19 (1) vector\<int> v(10,42);    (2) vector\<int> {42,42,42...,42};  (3) vector\<int> v;for(int i=0;i!=10;i++) v.push_pack(42);第一种，定义时直接初始化而且比较简单

3.21 略

3.22 略

3.24 略

3.25 略

3.26 在数值运算上，两者结果相同，但是beg+end有int上溢的风险；mid=beg+(beg+end)/2通用性更强，两个迭代器/指针的加法运算但是支持减法运算。

3.27 依次：a错误，必须是常量表达式；c错误，返回值未必是常量表达式；d错误，字符加上'\0'共需要12个字符空间，st长度不够；

3.28 sa中都是""，ia中都是0，sa2都是""，ia2元素位置；

3.29 无法自动增长缩小，不支持迭代器。array必须提前确定数组大小

3.30 ia\[0]不会被访问，ix为10时，会读到没有定义的内存空间

3.32 略

3.33 scores中的元素都是未知值，因为scores是一个局部变量

3.34 令p1指向p2指向的元素，当p1是常量指针时该行为非法

3.36 略

3.37 hello,每个字符一行；（不正确，此外还会继续输出直到遇到'\0'，所以会产生未定义的结果）

3.38 指针中存放的所指向元素的内存地址，两个已知元素的内存地址相加只能得到一个未定义的内存地址，这是的无意义。除非这个内存地址被提前定义过

3.39 略

3.43 略

3.44 略

3.45 略
