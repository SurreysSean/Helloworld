**chapter 2**

2.1 

> 1. 类型大小（最小值）
>> + int-16bit;
>> + long-32bit;
>> + long long-64bit;
>> + short-16bit;
> 2. 无符号数仅能表示非负数，带符号数则都可以表示。
> 3. double 64bit;float 32bit,double能表示的精度更高

2.2 选择double，能表示小数且高精度。

2.3 从上到下：32,2^32-32,32,-32,0,0

2.5 
> + a.字符，宽型字符，字符串，宽型字符串
> + b.整型，无符号整型，长整型，无符号长整型，8进制值，16进制值 
> + c.double,float,long double
> + d.int,unsigned,double,double

2.6 从上到下：10进制整型，8进制整型

2.7 依次："Who goes with Fergus\n"，字符串；31.4，long double；1024.0，float；3.14，long double

2.9 
> + 解释：非法定义，不合法的初始化操作；定义合法，隐式转换；非法定义，wage未被定义；定义合法，隐式转换。
> + 修改：(a)int input_value;cin>>input_value; (c)double salary=9999.99,wage=9999.99;

2.10 从上到下："",0,未知(**函数体内部**的**内置**类型不被初始化),""

2.11 依次：定义，定义，声明

2.12 依次：非法，合法，非法，非法，合法

2.13 100

2.14 合法，100 45

2.15 b 必须引用对象，d 引用必须初始化

2.16 依次：必须指定对象；合法,同d=i；合法，同i=d；类型必须同绑定对象匹配

2.17 10 10

2.18 略

2.19 引用同对象绑定，不是对象；指针是对象，存储对象内存空间的地址

2.20 i = i*i

2.21 (a)指针需要与被指向对象严格匹配；(b)指针应该存放对象的地址

2.22 依次：判断指针是否为空；判断p指向对象是否为0

2.23 略

2.24 void指针可存放任意对象的地址，long指针严格匹配long对象

2.25 
> + (a). ip:pointer\<int>,nullptr; i:int,0; r:reference,i;
> + (b). i:int,0; ip:pointer\<int>,0
> + (c). ip:pointer\<int>,nullptr; ip2:int,0

2.26 (a)常量必须初始化; (d)常量不可被修改。其他合法

2.27 依次：a.引用必须绑定对象；b.合法，指向int的常量指针；c.合法，常量引用可以直接绑定常量；d.合法，指向int常量的常量指针；e.合法，指针常量；f.不合法；g.合法，常量和常量引用

2.28 依次：i:整型；cp:常量指针，不合法，必须初始化；pl：int*；p2:常量指针，不合法，必须初始化；ic:整型常量，不合法，必须初始化；r:常量引用；p3：指向整型常量的常量指针,不合法，必须初始化；p:指向常量的指针

2.29 依次：a.合法，将const变量的值赋值给非const；b.不合法，非常量指针不能指向常量对象；c.不合法，非常量指针不能指向常量对象;d.合法，类型匹配；e.合法，int常量指针指向int对象，类型匹配；f.不合法，常变量不能重新赋值

2.30 依次：顶层；无const；无const；无const；底层；顶层&底层；底层

2.31 依次：合法；不合法；合法；不合法；不合法（常量指针不可修改指向）；

2.32 int null =0,*p = \&null;

2.33 42;42;42;不能将整型赋值给指针;不能将整型赋值给指针;常量引用不能被赋值（记住，c++是强类型语言，自动类型转化不能转指针）

2.34 略

2.35 i:const int;j:int;k:const int&;p:const int*;j2:const int;k2:const int&

2.36 a:int 4;b:int 4;c:int 4;d:int& 4

2.37 a:int 3;b:int 4;c:int 3;d:int& 4

2.38 
> + int a;auto b=a等同于decltype(a)b【int】;        
> + int \*a;auto b=\*a【int】不同于decltype(\*a) c【int&】; （同样可以距离const）

- - -
**chapter 3**

3.1 略

3.3 输入运算符：遇到空白字符或换行符结束输出；getline()：遇到换行符才结束

3.9 合法输出'\0'

3.11 合法，c应为const char&；(设置一个类型为auto的引用时，初始值中的常量属性仍然保留)

3.12 依次：二维int数组；不正确，类型不匹配；含有10个"null"元素的字符串数组

3.13 依次：0个;10个,都是0;10个,都是42;1个,10;2个,{10,42};10个,""（确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象，下题同理）;10个,"hi"

3.18 不合法，ivec大小为0,不能通过下标添加元素；revise:ivec.push_back(42);

3.19 (1) vector\<int> v(10,42);    (2) vector\<int> {42,42,42...,42};  (3) vector\<int> v;for(int i=0;i!=10;i++) v.push_pack(42);第一种，定义时直接初始化而且比较简单

3.21 略

3.22 略

3.24 略

3.25 略

3.26 在数值运算上，两者结果相同，但是beg+end有int上溢的风险；mid=beg+(beg+end)/2通用性更强，两个迭代器/指针的加法运算但是支持减法运算。

3.27 依次：a错误，必须是常量表达式；c错误，返回值未必是常量表达式；d错误，字符加上'\0'共需要12个字符空间，st长度不够；

3.28 sa中都是""，ia中都是0，sa2都是""，ia2元素位置；

3.29 无法自动增长缩小，不支持迭代器。array必须提前确定数组大小

3.30 ia\[0]不会被访问，ix为10时，会读到没有定义的内存空间

3.32 略

3.33 scores中的元素都是未知值，因为scores是一个局部变量

3.34 令p1指向p2指向的元素，当p1是常量指针时该行为非法

3.36 略

3.37 hello,每个字符一行；（不正确，此外还会继续输出直到遇到'\0'，所以会产生未定义的结果）

3.38 指针中存放的所指向元素的内存地址，两个已知元素的内存地址相加只能得到一个未定义的内存地址，这是的无意义。除非这个内存地址被提前定义过

3.39 略

3.43 略

3.44 略

3.45 略
- - -
**chapter 4**
4.1 105

4.2 \(b) *\(vec.begin\()+1)

4.3 略

4.4 （12/3*4）+（5*15）+（24%4/2），res=91

4.5 依次：-86；-18；0；-2

4.6 if(i%2)

4.7 类型的值超出了该类型能表达的范围。int_max+1,int_min-1,unsigned(0)-1

4.8 先左后右的书序进行求值

4.9 cp不为空并且*cp不为零

4.11 
```cpp
if (a>b&&b>c&&c>d){}
```

4.12 等同于i!=\(j\<k)

4.13 依次：i=d=3;1=3,d=3.5;

4.14 依次：报错；i赋值为42，if condition为真；

4.15 不能将指针类型变量赋值给整型变量。dval = ival =0;pi=0;

4.16 \(a)逻辑运算符优先于赋值运算符，所以会将表达式getPtr\()!=0的值赋值给p；\(b)condition中是赋值运算而不是逻辑运算，所以i=1024表达式值为1，if condition恒为真
```cpp
//revise a
if ((p=getPtr())!=0){}
//revise b
if (i==1024){}
```

4.17 前置运算符先将变量取到寄存器中，后内存中变量运算；后置运算符先将内存中的变量运算，再取到寄存器中

4.18 无法输出vector中的第一个元素而且会产生越界错误

4.19 依次：若ptr不为空，且*ptr不为0，ptr+=1；ival且ival+1都不等于0，执行ival+=1；等同于vec\[ival]\<=vec\[ival+1],ival+=1

4.20 依次：解引用iter，iter自增；解引用iter，值自增；不合法，先执行成员选择符，但是'.'与iter不匹配；iter指向字符串是否为空；
iter自增，解引用iter；判断iter指向字符串是否为空，iter自增

4.22 略（条件运算符版本需条件运算符嵌套）

4.23 加法运算符优先于条件运算符，最后会变成判断字符类型常量和字符串类型变量是否相等，类型不匹配无法通过编译

4.24 
```cpp
//等同于
auto finalgrade = (grade>90)?"high pass":((grade<60?"fail":"pass"));
```

4.25 '@'，此处类型提升成32位：0x00003880

4.26 unsigned int 最小可能只有16位，可能无法表示30名学生

4.27 依次：3；7；1；1；

4.28 略，懒得搞

4.29 10;2\(指针占64位) 

4.30 
```cpp
//依次
sizeof(x)+y;
sizeof(p->mem[i]);
sizeof(a)<b;
sizeof(f());
```

4.31 前置编译效率更高；但是结果相同

4.32 计数loop：ix从0到5，ptr从ia\[0]指向ia\[5]

4.33 someValue为真执行\(++x,++y)，否则执行\(--x,--y)

4.34 依次：float转bool;int转float转double；char转int转double

4.35 依次：char转int转char；int转double,unsigned转double,最后double转float；unsigned转int转double；int转float转double转char

4.36 i*=static_cast\<int>(d)

4.37 依次：pv = static_cast\<void*>\(const_cast\<string*>ps); i = static_cast\<int>\(*pc);pv = static_cast\<void*>\(&d);pc = static_cast\<char*>\(pv);

4.38 j/i的结果强制转换为double类型